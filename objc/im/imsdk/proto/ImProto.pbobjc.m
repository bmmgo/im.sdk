// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ImProto.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "ImProto.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - ImProtoRoot

@implementation ImProtoRoot

@end

#pragma mark - ImProtoRoot_FileDescriptor

static GPBFileDescriptor *ImProtoRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"IM.Protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum PackageCategory

GPBEnumDescriptor *PackageCategory_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Ping\000Login\000Logout\000SendToUser\000SendToChann"
        "el\000ReceivedUserMsg\000ReceivedChannelMsg\000Bi"
        "ndToChannel\000UnbindToChannel\000BindToGroup\000"
        "UnbindToGroup\000SendToGroup\000ReceivedGroupM"
        "sg\000Result\000AdminSend\000SubUserLogin\000UnsubUs"
        "erLogin\000PubUserLogin\000";
    static const int32_t values[] = {
        PackageCategory_Ping,
        PackageCategory_Login,
        PackageCategory_Logout,
        PackageCategory_SendToUser,
        PackageCategory_SendToChannel,
        PackageCategory_ReceivedUserMsg,
        PackageCategory_ReceivedChannelMsg,
        PackageCategory_BindToChannel,
        PackageCategory_UnbindToChannel,
        PackageCategory_BindToGroup,
        PackageCategory_UnbindToGroup,
        PackageCategory_SendToGroup,
        PackageCategory_ReceivedGroupMsg,
        PackageCategory_Result,
        PackageCategory_AdminSend,
        PackageCategory_SubUserLogin,
        PackageCategory_UnsubUserLogin,
        PackageCategory_PubUserLogin,
    };
    static const char *extraTextFormatInfo = "\022\000\004\000\001\005\000\002\006\000\003\n\000\004\r\000\005\017\000\006\022\000\007\r\000\010\017\000\t\013\000\n\r\000\013\013\000\014\020\000\r\006\000\016\t\000\017\014\000\020\016\000\021\014\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(PackageCategory)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:PackageCategory_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL PackageCategory_IsValidValue(int32_t value__) {
  switch (value__) {
    case PackageCategory_Ping:
    case PackageCategory_Login:
    case PackageCategory_Logout:
    case PackageCategory_SendToUser:
    case PackageCategory_SendToChannel:
    case PackageCategory_ReceivedUserMsg:
    case PackageCategory_ReceivedChannelMsg:
    case PackageCategory_BindToChannel:
    case PackageCategory_UnbindToChannel:
    case PackageCategory_BindToGroup:
    case PackageCategory_UnbindToGroup:
    case PackageCategory_SendToGroup:
    case PackageCategory_ReceivedGroupMsg:
    case PackageCategory_Result:
    case PackageCategory_AdminSend:
    case PackageCategory_SubUserLogin:
    case PackageCategory_UnsubUserLogin:
    case PackageCategory_PubUserLogin:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ResultCode

GPBEnumDescriptor *ResultCode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000NeedLogin\000AuthFailed\000";
    static const int32_t values[] = {
        ResultCode_Success,
        ResultCode_NeedLogin,
        ResultCode_AuthFailed,
    };
    static const char *extraTextFormatInfo = "\003\000\007\000\001\t\000\002\n\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResultCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResultCode_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResultCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResultCode_Success:
    case ResultCode_NeedLogin:
    case ResultCode_AuthFailed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SocketPackage

@implementation SocketPackage

@dynamic seq;
@dynamic category;
@dynamic content;

typedef struct SocketPackage__storage_ {
  uint32_t _has_storage_[1];
  int32_t seq;
  PackageCategory category;
  NSData *content;
} SocketPackage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "seq",
        .dataTypeSpecific.className = NULL,
        .number = SocketPackage_FieldNumber_Seq,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SocketPackage__storage_, seq),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "category",
        .dataTypeSpecific.enumDescFunc = PackageCategory_EnumDescriptor,
        .number = SocketPackage_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SocketPackage__storage_, category),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = SocketPackage_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SocketPackage__storage_, content),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SocketPackage class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SocketPackage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001C\000\002H\000\003G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SocketPackage_Category_RawValue(SocketPackage *message) {
  GPBDescriptor *descriptor = [SocketPackage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SocketPackage_FieldNumber_Category];
  return GPBGetMessageInt32Field(message, field);
}

void SetSocketPackage_Category_RawValue(SocketPackage *message, int32_t value) {
  GPBDescriptor *descriptor = [SocketPackage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SocketPackage_FieldNumber_Category];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SocketResult

@implementation SocketResult

@dynamic category;
@dynamic code;
@dynamic message;
@dynamic userTags, userTags_Count;

typedef struct SocketResult__storage_ {
  uint32_t _has_storage_[1];
  PackageCategory category;
  ResultCode code;
  NSString *message;
  NSMutableDictionary *userTags;
} SocketResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "category",
        .dataTypeSpecific.enumDescFunc = PackageCategory_EnumDescriptor,
        .number = SocketResult_FieldNumber_Category,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SocketResult__storage_, category),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = ResultCode_EnumDescriptor,
        .number = SocketResult_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SocketResult__storage_, code),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = SocketResult_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SocketResult__storage_, message),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTags",
        .dataTypeSpecific.className = NULL,
        .number = SocketResult_FieldNumber_UserTags,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SocketResult__storage_, userTags),
        .flags = GPBFieldMapKeyString | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SocketResult class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SocketResult__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001H\000\002D\000\003G\000\004H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SocketResult_Category_RawValue(SocketResult *message) {
  GPBDescriptor *descriptor = [SocketResult descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SocketResult_FieldNumber_Category];
  return GPBGetMessageInt32Field(message, field);
}

void SetSocketResult_Category_RawValue(SocketResult *message, int32_t value) {
  GPBDescriptor *descriptor = [SocketResult descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SocketResult_FieldNumber_Category];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t SocketResult_Code_RawValue(SocketResult *message) {
  GPBDescriptor *descriptor = [SocketResult descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SocketResult_FieldNumber_Code];
  return GPBGetMessageInt32Field(message, field);
}

void SetSocketResult_Code_RawValue(SocketResult *message, int32_t value) {
  GPBDescriptor *descriptor = [SocketResult descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SocketResult_FieldNumber_Code];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - LoginToken

@implementation LoginToken

@dynamic userId;
@dynamic token;
@dynamic versionCode;
@dynamic appkey;
@dynamic isAdmin;
@dynamic versionName;

typedef struct LoginToken__storage_ {
  uint32_t _has_storage_[1];
  int32_t versionCode;
  NSString *userId;
  NSString *token;
  NSString *appkey;
  NSString *versionName;
} LoginToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = LoginToken_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginToken__storage_, userId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = LoginToken_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LoginToken__storage_, token),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "versionCode",
        .dataTypeSpecific.className = NULL,
        .number = LoginToken_FieldNumber_VersionCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LoginToken__storage_, versionCode),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "appkey",
        .dataTypeSpecific.className = NULL,
        .number = LoginToken_FieldNumber_Appkey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LoginToken__storage_, appkey),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAdmin",
        .dataTypeSpecific.className = NULL,
        .number = LoginToken_FieldNumber_IsAdmin,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "versionName",
        .dataTypeSpecific.className = NULL,
        .number = LoginToken_FieldNumber_VersionName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LoginToken__storage_, versionName),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginToken class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginToken__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001EA\000\002E\000\003K\000\004F\000\005G\000\006K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendUserMessage

@implementation SendUserMessage

@dynamic receiver;
@dynamic type;
@dynamic content;
@dynamic userTags, userTags_Count;
@dynamic sender;

typedef struct SendUserMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSString *receiver;
  NSString *content;
  NSMutableDictionary *userTags;
  NSString *sender;
} SendUserMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "receiver",
        .dataTypeSpecific.className = NULL,
        .number = SendUserMessage_FieldNumber_Receiver,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendUserMessage__storage_, receiver),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = SendUserMessage_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendUserMessage__storage_, type),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = SendUserMessage_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendUserMessage__storage_, content),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTags",
        .dataTypeSpecific.className = NULL,
        .number = SendUserMessage_FieldNumber_UserTags,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendUserMessage__storage_, userTags),
        .flags = GPBFieldMapKeyString | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = SendUserMessage_FieldNumber_Sender,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendUserMessage__storage_, sender),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendUserMessage class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendUserMessage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001H\000\002D\000\003G\000\004H\000\005F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReceivedUserMessage

@implementation ReceivedUserMessage

@dynamic msgId;
@dynamic sender;
@dynamic type;
@dynamic content;
@dynamic userTags, userTags_Count;
@dynamic sendTime;

typedef struct ReceivedUserMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t sendTime;
  NSString *msgId;
  NSString *sender;
  NSString *content;
  NSMutableDictionary *userTags;
} ReceivedUserMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedUserMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReceivedUserMessage__storage_, msgId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedUserMessage_FieldNumber_Sender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReceivedUserMessage__storage_, sender),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedUserMessage_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReceivedUserMessage__storage_, type),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedUserMessage_FieldNumber_Content,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ReceivedUserMessage__storage_, content),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTags",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedUserMessage_FieldNumber_UserTags,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ReceivedUserMessage__storage_, userTags),
        .flags = GPBFieldMapKeyString | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedUserMessage_FieldNumber_SendTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ReceivedUserMessage__storage_, sendTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReceivedUserMessage class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceivedUserMessage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001DA\000\002F\000\003D\000\004G\000\005H\000\006H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendChannelMessage

@implementation SendChannelMessage

@dynamic channelId;
@dynamic type;
@dynamic content;
@dynamic userTags, userTags_Count;
@dynamic sender;

typedef struct SendChannelMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSString *channelId;
  NSString *content;
  NSMutableDictionary *userTags;
  NSString *sender;
} SendChannelMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = SendChannelMessage_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendChannelMessage__storage_, channelId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = SendChannelMessage_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendChannelMessage__storage_, type),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = SendChannelMessage_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendChannelMessage__storage_, content),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTags",
        .dataTypeSpecific.className = NULL,
        .number = SendChannelMessage_FieldNumber_UserTags,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendChannelMessage__storage_, userTags),
        .flags = GPBFieldMapKeyString | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = SendChannelMessage_FieldNumber_Sender,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendChannelMessage__storage_, sender),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendChannelMessage class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendChannelMessage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001HA\000\002D\000\003G\000\004H\000\005F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReceivedChannelMessage

@implementation ReceivedChannelMessage

@dynamic msgId;
@dynamic sender;
@dynamic channelId;
@dynamic type;
@dynamic content;
@dynamic userTags, userTags_Count;
@dynamic sendTime;

typedef struct ReceivedChannelMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t sendTime;
  NSString *msgId;
  NSString *sender;
  NSString *channelId;
  NSString *content;
  NSMutableDictionary *userTags;
} ReceivedChannelMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedChannelMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReceivedChannelMessage__storage_, msgId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedChannelMessage_FieldNumber_Sender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReceivedChannelMessage__storage_, sender),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedChannelMessage_FieldNumber_ChannelId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReceivedChannelMessage__storage_, channelId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedChannelMessage_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ReceivedChannelMessage__storage_, type),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedChannelMessage_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ReceivedChannelMessage__storage_, content),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTags",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedChannelMessage_FieldNumber_UserTags,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ReceivedChannelMessage__storage_, userTags),
        .flags = GPBFieldMapKeyString | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedChannelMessage_FieldNumber_SendTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ReceivedChannelMessage__storage_, sendTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReceivedChannelMessage class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceivedChannelMessage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001DA\000\002F\000\003HA\000\004D\000\005G\000\006H\000\007H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Channel

@implementation Channel

@dynamic channelId;

typedef struct Channel__storage_ {
  uint32_t _has_storage_[1];
  NSString *channelId;
} Channel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = Channel_FieldNumber_ChannelId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Channel__storage_, channelId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Channel class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Channel__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001HA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserGroup

@implementation UserGroup

@dynamic userId;
@dynamic groupIdsArray, groupIdsArray_Count;

typedef struct UserGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *userId;
  NSMutableArray *groupIdsArray;
} UserGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userId",
        .dataTypeSpecific.className = NULL,
        .number = UserGroup_FieldNumber_UserId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserGroup__storage_, userId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupIdsArray",
        .dataTypeSpecific.className = NULL,
        .number = UserGroup_FieldNumber_GroupIdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UserGroup__storage_, groupIdsArray),
        .flags = GPBFieldRepeated | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserGroup class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserGroup__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001EA\000\002\000GroupIDs\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendGroupMessage

@implementation SendGroupMessage

@dynamic groupId;
@dynamic type;
@dynamic content;
@dynamic userTags, userTags_Count;
@dynamic sender;

typedef struct SendGroupMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSString *groupId;
  NSString *content;
  NSMutableDictionary *userTags;
  NSString *sender;
} SendGroupMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = SendGroupMessage_FieldNumber_GroupId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendGroupMessage__storage_, groupId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = SendGroupMessage_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendGroupMessage__storage_, type),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = SendGroupMessage_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SendGroupMessage__storage_, content),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTags",
        .dataTypeSpecific.className = NULL,
        .number = SendGroupMessage_FieldNumber_UserTags,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendGroupMessage__storage_, userTags),
        .flags = GPBFieldMapKeyString | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = SendGroupMessage_FieldNumber_Sender,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SendGroupMessage__storage_, sender),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendGroupMessage class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendGroupMessage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001FA\000\002D\000\003G\000\004H\000\005F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReceivedGroupMessage

@implementation ReceivedGroupMessage

@dynamic msgId;
@dynamic sender;
@dynamic groupId;
@dynamic type;
@dynamic content;
@dynamic userTags, userTags_Count;
@dynamic sendTime;

typedef struct ReceivedGroupMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t sendTime;
  NSString *msgId;
  NSString *sender;
  NSString *groupId;
  NSString *content;
  NSMutableDictionary *userTags;
} ReceivedGroupMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedGroupMessage_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReceivedGroupMessage__storage_, msgId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sender",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedGroupMessage_FieldNumber_Sender,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReceivedGroupMessage__storage_, sender),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "groupId",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedGroupMessage_FieldNumber_GroupId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReceivedGroupMessage__storage_, groupId),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedGroupMessage_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ReceivedGroupMessage__storage_, type),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedGroupMessage_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ReceivedGroupMessage__storage_, content),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userTags",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedGroupMessage_FieldNumber_UserTags,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ReceivedGroupMessage__storage_, userTags),
        .flags = GPBFieldMapKeyString | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sendTime",
        .dataTypeSpecific.className = NULL,
        .number = ReceivedGroupMessage_FieldNumber_SendTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ReceivedGroupMessage__storage_, sendTime),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReceivedGroupMessage class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReceivedGroupMessage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001DA\000\002F\000\003FA\000\004D\000\005G\000\006H\000\007H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AdminMessage

@implementation AdminMessage

@dynamic receiver;
@dynamic category;
@dynamic messageContent;

typedef struct AdminMessage__storage_ {
  uint32_t _has_storage_[1];
  PackageCategory category;
  NSString *receiver;
  NSData *messageContent;
} AdminMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "receiver",
        .dataTypeSpecific.className = NULL,
        .number = AdminMessage_FieldNumber_Receiver,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AdminMessage__storage_, receiver),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "category",
        .dataTypeSpecific.enumDescFunc = PackageCategory_EnumDescriptor,
        .number = AdminMessage_FieldNumber_Category,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AdminMessage__storage_, category),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor,
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "messageContent",
        .dataTypeSpecific.className = NULL,
        .number = AdminMessage_FieldNumber_MessageContent,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AdminMessage__storage_, messageContent),
        .flags = GPBFieldOptional | GPBFieldTextFormatNameCustom,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AdminMessage class]
                                     rootClass:[ImProtoRoot class]
                                          file:ImProtoRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AdminMessage__storage_)
                                         flags:0];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001H\000\002H\000\003N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AdminMessage_Category_RawValue(AdminMessage *message) {
  GPBDescriptor *descriptor = [AdminMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AdminMessage_FieldNumber_Category];
  return GPBGetMessageInt32Field(message, field);
}

void SetAdminMessage_Category_RawValue(AdminMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [AdminMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AdminMessage_FieldNumber_Category];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
